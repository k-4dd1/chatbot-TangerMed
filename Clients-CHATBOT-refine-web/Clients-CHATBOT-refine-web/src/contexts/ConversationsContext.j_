'use client';

import { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import apiService from '../services/api';

// Create the context
const ConversationsContext = createContext(undefined);

// Provider component
export const ConversationsProvider = ({ children }) => {
  // Core shared state
  const [conversations, setConversations] = useState([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [lastMessageCache, setLastMessageCache] = useState(new Map());
  
  const router = useRouter();

  // Don't auto-load conversations on mount - only load when explicitly called
  // This prevents trying to load conversations before user authentication

  const loadConversations = useCallback(async () => {
    try {
      console.log('ðŸ”„ Loading conversations from ConversationsProvider');
      setIsLoading(true);
      setError(null);
      
      const fetchedConversations = await apiService.getConversations();
      console.log('fetchedConversations', fetchedConversations);
      console.log(`fetchedConversations.length`, fetchedConversations.length);
      // Normalize conversations to ensure they have proper timestamps and lastMessage
      const normalizedConversations = fetchedConversations.map(conv => {
        const now = new Date();
        const createdAt = conv.createdAt || conv.created_at || now.toISOString();
        const updatedAt = conv.updatedAt || conv.updated_at || createdAt;
        
        // Validate dates - if they're in the future, use current time
        const createdDate = new Date(createdAt);
        const updatedDate = new Date(updatedAt);
        
        // Compute lastMessage from various possible sources
        let lastMessage = 'Aucun message';
        
        // Check multiple possible sources for the last message
        if (conv.lastMessage) {
          lastMessage = conv.lastMessage;
        } else if (conv.last_message) {
          lastMessage = conv.last_message;
        } else if (conv.preview) {
          lastMessage = conv.preview;
        } else if (conv.messages && conv.messages.length > 0) {
          const lastMsg = conv.messages[conv.messages.length - 1];
          lastMessage = lastMsg.content || lastMsg.message || 'Message sans contenu';
        } else if (conv.summary) {
          lastMessage = conv.summary;
        }
        
        return {
          ...conv,
          title: conv.title || 'Nouvelle conversation',
          createdAt: (isNaN(createdDate.getTime()) || createdDate > now) ? now.toISOString() : createdAt,
          updatedAt: (isNaN(updatedDate.getTime()) || updatedDate > now) ? now.toISOString() : updatedAt,
          // Temporarily don't filter messages to debug the structure
          messages: conv.messages || [],
          // Ensure we always have a lastMessage property
          lastMessage: lastMessage
        };
      });
      
      setConversations(normalizedConversations);
    } catch (error) {
      console.error('Failed to load conversations:', error);
      setError('Erreur lors du chargement des conversations');
      
      // Handle authentication errors
      if (error.message.includes('Authentication required') || error.message.includes('401')) {
        if (typeof window !== 'undefined') {
          window.location.href = '/web/login';
        }
      }
    } finally {
      setIsLoading(false);
    }
  }, []);

  const createNewConversation = useCallback(async (title = 'Nouvelle conversation') => {
    console.log('Creating conversation with title:', title);
    try {
      setError(null);
      const newConversation = await apiService.createConversation(title);
      
      // Ensure the conversation has proper timestamps and title for sorting
      const conversationWithTimestamp = {
        ...newConversation,
        title: newConversation.title || title,
        createdAt: newConversation.createdAt || new Date().toISOString(),
        updatedAt: newConversation.updatedAt || new Date().toISOString(),
        messages: []
      };
      
      // Update conversations list immediately (optimistic update)
      setConversations(prev => [conversationWithTimestamp, ...prev]);
      
      return conversationWithTimestamp;
    } catch (error) {
      console.error('Failed to create conversation:', error);
      setError('Erreur lors de la crÃ©ation de la conversation');
      throw error;
    }
  }, [router]);

  const deleteConversation = useCallback(async (id) => {
    try {
      setError(null);
      
      // Check if conversation exists in local state
      const conversationExists = conversations.find(conv => conv.id === id);
      if (!conversationExists) {
        console.log(`Conversation ${id} not found in local state, skipping deletion`);
        return;
      }
      
      // First, optimistically remove from local state
      const originalConversations = conversations;
      setConversations(prev => prev.filter(conv => conv.id !== id));
      
      try {
        await apiService.deleteConversation(id);
      } catch (apiError) {
        // If the conversation doesn't exist on the backend, that's actually fine
        // It means it was already deleted or never existed there
        if (apiError.message.includes('does not exist') || 
            apiError.message.includes('not found') ||
            apiError.message.includes('404')) {
          console.log(`Conversation ${id} doesn't exist on backend, removing from local state only`);
          // Keep the conversation removed from local state
          return;
        }
        
        // For other API errors, restore the original state and re-throw
        console.error('API error while deleting conversation:', apiError);
        setConversations(originalConversations);
        throw apiError;
      }
      
      // Optionally refresh conversations from backend to ensure sync
      // This helps prevent future sync issues
      setTimeout(() => {
        loadConversations().catch(err => 
          console.warn('Failed to refresh conversations after deletion:', err)
        );
      }, 1000);
      
    } catch (error) {
      console.error('Failed to delete conversation:', error);
      setError('Erreur lors de la suppression de la conversation');
      throw error;
    }
  }, [conversations, loadConversations]);

  const saveEdit = useCallback(async (id, newTitle) => {
    if (!newTitle.trim()) return;

    try {
      setError(null);
      
      // Update the conversation title via API if needed
      // Note: The API might not have an updateTitle endpoint, so we'll just update locally
      // If you have an API endpoint for updating titles, uncomment and use:
      // await apiService.updateConversationTitle(id, newTitle.trim());
      
      // Update local state
      setConversations(prev =>
        prev.map(conv =>
          conv.id === id
            ? { ...conv, title: newTitle.trim(), updatedAt: new Date().toISOString() }
            : conv
        )
      );
    } catch (error) {
      console.error('Failed to update conversation title:', error);
      setError('Erreur lors de la mise Ã  jour du titre');
      throw error;
    }
  }, []);

  const updateConversationTimestamp = useCallback((id) => {
    setConversations(prev => 
      prev.map(conv => 
        conv.id === id 
          ? { ...conv, updatedAt: new Date().toISOString() }
          : conv
      )
    );
  }, []);

  const updateConversationTitle = useCallback((conversationId, userMessage) => {
    // Generate a title from the user message (first 50 characters)
    let newTitle = userMessage.trim();
    
    // Remove common question words and clean up
    newTitle = newTitle.replace(/^(comment|pourquoi|quand|oÃ¹|qui|que|quoi|combien|est-ce que|peux-tu|pouvez-vous|aide-moi|aidez-moi)\s+/i, '');
    
    // Capitalize first letter
    newTitle = newTitle.charAt(0).toUpperCase() + newTitle.slice(1);
    
    // Truncate to reasonable length
    if (newTitle.length > 50) {
      newTitle = newTitle.substring(0, 50).trim() + '...';
    }
    
    // Fallback if the message is too short or empty
    if (newTitle.length < 3) {
      newTitle = 'Nouvelle conversation';
    }

    console.log('ðŸ·ï¸ Updating conversation title to:', newTitle);

    setConversations(prev => 
      prev.map(conv => 
        conv.id === conversationId 
          ? { ...conv, title: newTitle, updatedAt: new Date().toISOString() }
          : conv
      )
    );

    return newTitle;
  }, []);

  const addMessage = useCallback((conversationId, message) => {
    setConversations(prev => 
      prev.map(conv => {
        if (conv.id === conversationId) {
          const existingMessages = conv.messages || [];
          // Check if message with same ID already exists
          const messageExists = existingMessages.some(existingMsg => existingMsg.id === message.id);
          
          if (messageExists) {
            console.warn('âš ï¸ Attempt to add duplicate message with ID:', message.id);
            return conv; // Return unchanged conversation
          }
          
          const updatedMessages = [...existingMessages, message];
          const newLastMessage = message.content || message.message || 'Message sans contenu';
          
          // Update the cache with the new last message
          setLastMessageCache(prev => new Map(prev.set(conversationId, newLastMessage)));
          
          return {
            ...conv,
            messages: updatedMessages,
            // Update lastMessage to the content of the new message
            lastMessage: newLastMessage,
            updatedAt: new Date().toISOString()
          };
        }
        return conv;
      })
    );
  }, []);

  const getConversationById = useCallback((id) => {
    return conversations.find(conv => conv.id === id);
  }, [conversations]);

  const fetchLastMessage = useCallback(async (conversationId) => {
    // Check cache first
    if (lastMessageCache.has(conversationId)) {
      return lastMessageCache.get(conversationId);
    }

    try {
      console.log('ðŸ” Fetching messages for conversation:', conversationId);
      const messages = await apiService.getConversationMessages(conversationId);
      
      let lastMessage = 'Aucun message';
      if (messages && messages.length > 0) {
        const lastMsg = messages[messages.length - 1];
        lastMessage = lastMsg.content || lastMsg.message || 'Message sans contenu';
      }

      // Cache the result
      setLastMessageCache(prev => new Map(prev.set(conversationId, lastMessage)));
      
      console.log('ðŸ’¾ Cached last message for', conversationId, ':', lastMessage);
      return lastMessage;
    } catch (error) {
      console.error('âŒ Failed to fetch last message for conversation', conversationId, ':', error);
      const fallbackMessage = 'Erreur de chargement';
      
      // Cache the error state to avoid repeated requests
      setLastMessageCache(prev => new Map(prev.set(conversationId, fallbackMessage)));
      return fallbackMessage;
    }
  }, [lastMessageCache]);

  const exportConversations = useCallback(() => {
    try {
      const dataStr = JSON.stringify(conversations, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      
      const link = document.createElement('a');
      link.href = URL.createObjectURL(dataBlob);
      link.download = `conversations_${new Date().toISOString().split('T')[0]}.json`;
      link.click();
    } catch (error) {
      console.error('Failed to export conversations:', error);
      setError('Erreur lors de l\'exportation des conversations');
    }
  }, [conversations]);

  const value = {
    // State
    conversations,
    isLoading,
    error,
    
    // Actions
    loadConversations,
    createNewConversation,
    deleteConversation,
    saveEdit,
    updateConversationTimestamp,
    updateConversationTitle,
    addMessage,
    getConversationById,
    fetchLastMessage,
    exportConversations
  };

  return (
    <ConversationsContext.Provider value={value}>
      {children}
    </ConversationsContext.Provider>
  );
};

// Custom hook to use the context
export const useConversationsContext = () => {
  const context = useContext(ConversationsContext);
  if (context === undefined) {
    throw new Error('useConversationsContext must be used within a ConversationsProvider');
  }
  return context;
}; 